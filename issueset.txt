ch01:mymore.c
	关于标准输入输出的缓冲区问题。像getchar gets 等这种C 标准库中的输入输出，都是从标准输入缓冲区读入，输出到标准输出的缓冲区的。用能听懂的话讲，就是你从键盘的输入的东西，它都是放在标准输入缓冲区中的，当你按下enter键的时候，才开始往getchar gets中读。 输出的时候也是输出到缓冲区中去，当遇到\n或者强制刷新的时候，才往屏幕上显示的。
	当使用getchar时，会因为缓冲区的问题，读入\n，其实这个enter键只是表明结束这次的输入，但是依然会保存到缓冲区中去，因此getchar依然会读取到。还有如果下次使用getchar时，缓冲区依然还有残留值，getchar会继续读入，而不需要等待我们输入，因为上次的enter已经让缓冲区有内容了，getchar只要是缓冲区有内容，就能继续读，而不是等待我们输入。
	未避免缓冲区的残留对新的输入或者输出造成影响：在每个最后不带\n的printf后面加fflush(stdout);在每个不想受接收缓冲区旧内容影响的scanf前面加rewind(stdin);另外请检查scanf的返回值。
	
	清空输入缓冲区。rewind
	立即刷新输出缓冲区/即立即将输出缓冲区输入到屏幕。 fflush

	ref：http://bbs.csdn.net/topics/390471195
	http://www.cnblogs.com/sky-heaven/p/5016401.html
	http://blog.csdn.net/gaopu12345/article/details/30457329
	https://zhidao.baidu.com/question/567502664.html

关于 printf("\033[7m more? \033[m"); \033[xxx 表示设置颜色。
ref： http://bbs.csdn.net/topics/380060335
https://zhidao.baidu.com/question/198689143734913405.html

关于puts gets getc putc getchar<=>getc(stdin) putchar  fputs fgets fgetc fputc: 
以上都是为标准IO(C标准库)设计的。不带f是默认文件指针指向标准输出，输入的。 带f是指定文件指针。puts 为输出添加\n。gets读取换行符并将其丢弃。fputs，fgets 没有，该怎样就怎样。
标准IO 是带缓冲的IO，就是说，标准I/O默认采用了缓冲机制，比如调用fopen函数，不仅打开一个文件，而且建立了一个缓冲区（读写模式下将建立两个缓冲区），还创建了一个包含文件和缓冲区相关数据的数据结构。比如读取标准输入时，实际上是将标准输入如键盘，放到一个缓冲区中去。 当遇到\n或者强制输入时，才会将缓冲区的内容读取到程序中。输出到标准输出时，是将输出内容放到输出缓冲区，当遇到\n或者强制刷新输出时，才会输出到标准输出,即屏幕上去。
如果尝试读取达到文件结尾，标准IO的getc会返回特殊值EOF，而fgets碰到EOF会返回NULL。 单个字符的是EOF， 一整个字符串的gets是NULL。
IO：标准IO（带缓冲）和文件IO（不带缓冲）。前者一般是C标准库API，如fread fgets；后者是系统API，如read，write。
ref：
http://blog.csdn.net/lemon_fantasy/article/details/3394651
https://zhidao.baidu.com/question/581325672.html
http://bbs.csdn.net/topics/20422642


关于read 也是有缓冲区。
ssize_t read(int fd, void *buf, size_t count);
参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移。注意这个读写位置和使用C标准I/O库时的读写位置有可能不同，这个读写位置是记在内核中的，而使用C标准I/O库时的读写位置是用户空间I/O缓冲区中的位置。比如用fgetc读一个字节，fgetc有可能从内核中预读1024个字节到I/O缓冲区中，再返回第一个字节，这时该文件在内核中记录的读写位置是1024，而在FILE结构体中记录的读写位置是1。注意返回值类型是ssize_t，表示有符号的size_t，这样既可以返回正的字节数、0（表示到达文件末尾）也可以返回负值-1（表示出错）。
read函数返回时，返回值说明了buf中前多少个字节是刚读上来的。有些情况下，实际读到的字节数（返回值）会小于请求读的字节数count，例如：读常规文件时，在读到count个字节之前已到达文件末尾。例如，距文件末尾还有30个字节而请求读100个字节，则read返回30，下次read将返回0。


关于使用键盘一输入就立即接收，而不是按enter键之后再处理。
使用getch 不是C标准库。linux 中使用curses.h
gcc 添加库 gcc mymore.c -lcurses
xcode 中添加库。Taraget->Build Settings->Other Linker Flags->加上 -lcurses
xcode中出错 Error opening terminal: unknown。
ref：
https://zhidao.baidu.com/question/231739888.html
https://baike.baidu.com/item/getch()/10996394
https://baike.baidu.com/item/getch/919674?fr=aladdin
http://blog.chinaunix.net/uid-46552-id-2116326.html
http://www.cnblogs.com/Quains/archive/2013/08/22/3276425.html
https://stackoverflow.com/questions/4919373/xcode-and-curses-h-with-error-opening-terminal



关于管道和重定向
管道：将上个命令的标准输出作为后一个命令的标准输入。






